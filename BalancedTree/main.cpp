/*
Реализация програмы для решения задачи по получению последовательности чисел, которую можно разложить в одно из известных вам сбалансированных деревьев.

Входные данные: некая последовательность чисел, вводимая пользователем с клавиатуры.

Выходные данные: набор чисел, входящих в заданную последовательность, собранных в такую последовательность, на основе которой можно сформировать сбалансированное дерево (АВЛ-, КЧ-, splay – дерево), без дополнительной балансировки. Либо можно вывести в консоль сформированное дерево.

Дополнительные условия:

1.       Дерево балансировки выбирается разработчиком. Т.е. алгоритм нахождения искомой последовательности может быть только для одного (необязательно) типа деревьев на ваш выбор.

2.       Программный код должен быть организован на основе объектно-ориентированной методологии программирования.

3.       Обязательно создание абстрактного класса узла, от которого произвести наследование для реализации класса узла определенного сбалансированного дерева.

4.       Функции перестроения деревьев, реализуются в классе-наследнике

5.       Методы для работы с деревьями: поиск, вставка и удаление узла по ключу, объявляются  в абстрактном классе.

6.       Алгоритм работы программы реализовать в исполняемом файле.

7. Придерживаться известных правил именования классов, функций, файлов. Каждый класс должен иметь свой заголовочный файл и файл реализации.

Дополнительные условия могут изменяться по договоренности с преподавателем.

В качестве ответа предоставить ссылку на репозиторий и приложить сформированнай exe-файл.
*/

#include "avltree.h"

int main(int argc, char** argv)
{   
    // Создаем АВЛ дерево
    AVLTree tree; 

    // Строки для ввода и считывания чисел
    std::string inputString,
                stringKey;

    
    std::cout << "Введите последовательность ключей (используйте любой разделитель на Ваше усмотрение):\n-> ";
    // Ввод исходных данных
    std::getline(std::cin, inputString);
    inputString += ' ';

    // Проходимся по строке
    for (size_t i = 0; i < inputString.length(); i++)
    {
        // Если символ под индексом это число или знак минуса, за которым следует число, то добавляем его в строковый ключ
        if (std::isdigit(inputString[i]) || (inputString[i] == '-' && std::isdigit(inputString.at(i+1)))) stringKey += inputString[i];
        
        // Если ввод числа прервался и в строковом ключе что-то было..
        else if (stringKey.length())
        {
            // ..создаем объект АВЛ узла на его основе
            AVLNode* nodePtr {new AVLNode {std::stoi(stringKey)}};
            
            // Добавляем его к АВЛ древу
            nodePtr->addNodeTo(&tree);
            
            // Очищаем строковый ключ
            stringKey.clear();
        }
    }

    // Выводим итоговую последовательность
    tree.printTaskAnswer();
    system("pause");
}

// cd C:\Users\user\Desktop\CPP\Mospolytech\BalancedTree
// g++ -o main.exe main.cpp avlnode.cpp avltree.cpp